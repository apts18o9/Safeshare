// firestore.rules
// These rules define who can read and write data in your Cloud Firestore database.
// They are crucial for WebRTC signaling, allowing senders and receivers to exchange
// necessary information (offers, answers, ICE candidates).

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Allow read/write access for any authenticated user to the public/data path
    // which is used for P2P transfer signaling.
    // This assumes that even anonymous users signed in will have a `request.auth != null`.
    // If no Firebase Auth is used at all (which is the case in your current frontend),
    // you might need to adjust rules to 'allow read, write: true;' for truly public access,
    // but it's generally safer to at least use anonymous auth.
    // The frontend code implicitly relies on `__initial_auth_token` for anonymous sign-in
    // provided by the Canvas environment, so `request.auth != null` will work.
    match /artifacts/{appId}/public/data/transfers/{shareCode} {
      allow read, write: if request.auth != null; // Allow read/write for the main transfer document
    }

    // Allow read/write access for any authenticated user to the sub-collections
    // for ICE candidates (senderCandidates and receiverCandidates).
    // These collections store the network information needed for peers to connect.
    match /artifacts/{appId}/public/data/transfers/{shareCode}/{collectionId}/{docId} {
      allow read, write: if request.auth != null; // Allow read/write for ICE candidate documents
    }

    // IMPORTANT: If you have other collections in your Firestore, define their rules here.
    // By default, if a collection is not explicitly matched, access is denied.
    // For example, if you later add user profiles, you'd need rules like:
    /*
    match /artifacts/{appId}/users/{userId}/{documents=**} {
      allow read, write: if request.auth.uid == userId; // Allow users to read/write their own data
    }
    */
  }
}
